### 불변 클래스

불변 클래스 정의

- 인스턴스의 내부 값을 수정할 수 없는 클래스
- 불변 클래스 안 필드 정보는 객체가 파괴될 때 까지 고정되어 달라지지 않는다.

불변 클래스 사례

- 자바 플랫폼 라이브러리 - String, 기본 타입 박싱 클래스, BigInteger, BigDecimal

장점

- 가변 클래스보다 설계, 구현이 용이하다.
- 오류가 생길 여지가 적고 안전하다.

불변 클래스 생성 규칙

- 객체 상태 변경 메서드(Setter : 변경자)를 제공하지 않는다.
- 클래스를  확장할 수 없도록 한다.
    - 하위 클래스에서 나쁜 의도로 객체 상태를 변하게 만드는 것을 막아줌
    - 상속을 막는 법 : 클래스를 final로 선언
- 모든 필드를 final로 선언한다.
    - 스레드로부터 안전하기 위해서도 필요
- 모든 필드를 private로 선언한다.
    - 필드가 참조하는 가변객체를 클라이언트가 접근하여 수정하는 일을 막아준다.
    - public final로 선언하면 불변 객체가 되나 내부 표현을 바꿀 수 없으므로 권하지는 않음.
- 자신 외에 내부 가변 컴포넌트에 접근할 수 없도록 한다.
    - 가변 객체를 참조하는 필드가 있다면 클라이언트가 객체 참조를 얻을 수 없도록 해야 한다.
    - 절대 그대로 클라이언트에 객체 참조를 제공해선 안된다.  접근자로도 마찬가지
    - 생성자, 접근자, readObject 메서드 모두에서 방어적 복사를 수행해야 한다.

    불변 클래스 예

    [불변 복소수 클래스]

    ```java
    public final class Complex {
        private final double re;
        private final double im;

        public static final Complex ZERO = new Complex(0, 0);
        public static final Complex ONE  = new Complex(1, 0);
        public static final Complex I    = new Complex(0, 1);

        public Complex(double re, double im) {
            this.re = re;
            this.im = im;
        }

        public double realPart()      { return re; }
        public double imaginaryPart() { return im; }

        public Complex plus(Complex c) {
            return new Complex(re + c.re, im + c.im);
        }

        public static Complex valueOf(double re, double im) {
            return new Complex(re, im);
        }

        public Complex minus(Complex c) {
            return new Complex(re - c.re, im - c.im);
        }

        public Complex times(Complex c) {
            return new Complex(re * c.re - im * c.im,
                    re * c.im + im * c.re);
        }

        public Complex dividedBy(Complex c) {
            double tmp = c.re * c.re + c.im * c.im;
            return new Complex((re * c.re + im * c.im) / tmp,
                    (im * c.re - re * c.im) / tmp);
        }

        @Override public boolean equals(Object o) {
            if (o == this)
                return true;
            if (!(o instanceof Complex))
                return false;
            Complex c = (Complex) o;

            return Double.compare(c.re, re) == 0
                    && Double.compare(c.im, im) == 0;
        }
        @Override public int hashCode() {
            return 31 * Double.hashCode(re) + Double.hashCode(im);
        }

        @Override public String toString() {
            return "(" + re + " + " + im + "i)";
        }
    }
    ```

    해석

    - 필드를 반환만 하는 접근자 메서드 정의
    - 자신을 수정하지 않고 새로운 인스턴스를 만들어 반환하는 함수형 프로그래밍 패턴 사용 (plus, minus, times, dividedBy 메서드)
    - 함수형 프로그래밍 패턴 메서드 이름에 전치사를 사용한 것은 객체 값이 변하지 않는다는 사실을 강조하기 위함
