### [equals 메서드의 재정의]

재정의하지 않은 equals 메서드

- 자기 자신인 인스턴스만 같게 된다.

equals 메서드를 재정의하면 문제가 발생할 가능성이 높으므로 아래 경우에 해당한다면 재정의 하지 않는게 좋음.

equals를 재정의하지 않는 것이 좋은 경우

- 동작하는 개체를 표현하는 클래스의 인스턴스가 고유하다 (예 : Thread)
- 논리적 동치성을 검사할 필요가 없는 인스턴스 (예 : Pattern 인스턴스들의 정규식이 일치하는지 판단하는 로직을 만들 필요가 없다면 equals를 재정의할 필요가 없다.)
- 상위 클래스에 재정의한 equals가 하위 클래스에도 똑같이 적용이 될 경우
- 클래스가 private 또는 패키지가 private 이면서 equals를 사용할 일이 없는 경우

equals 메서드 호출 방지 방법

```java
@Override public boolean equals(Object o) {
	throw new AssertionError();
}
```

equals를 재정의하는 것이 좋을 경우

- 상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의하지 않았을 경우 (예 : 값 클래스의 비교) 즉 값이 같은걸 비교하고 싶은데 값 클래스의 equals가 두 객체가 물리적으로 같은가 (객체 식별성(object identity))를 판별할 경우

String과 같은 인스턴스 통재 클래스면 equals를 재정의안해도 논리적 동치성 판별이 가능해짐.

### [equals 메서드 일반 규약]

equals 메서드는 동치관계(equivalence relation)를 구현하고 아래를 성립해야 한다.

- 반사성(reflexivity)
    - null 아닌 참조값 x → x.equals(x) = true
- 대칭성(symmetry)
    - null 아닌 참조값 x,y → x.equals(y) = true 이면 y.equals(x) = true
- 추이성(transitivity)
    - null 아닌 참조값 x,y, z → x.equals(y) = true 이고 y.equals(z) = true 이면 x.quals(z) = true
- 일관성(consistency)
    - null 아닌 참조값 x,y → x.equals(y) loop 시 항상 true 또는 false를 반환
- null 아님
    - null 아닌 참조값 x → x.equals(null) = false

※ 수많은 클래스들이 equals 규악을 지키는 것을 가정하고 동작하므로 equals 재정의시 반드시 규약을 지켜야한다!!!

반사성

- 객체는 자기 자신과 같아야 한다.

대칭성

- 서로에 대한 동치 여부에 똑같이 답해야 한다.
- 직접 구현한 CaseInsentiveString 클래스와 String 클래스 예시 → CaseInsentiveString의 equals는 String과 비교를 시도하여 true를 반환, 그러나 String의 equals는 CaseInsentiveString의 존재를 모르므로 false 반환 → 이는 대칭성을 위배하게 된다.

추이성

- 1번째 객체가 2번째 객체와 같고 2번째 객체가 3번째 객체가 같다면 1번째 객체와 3번째 객체도 같다.

equals를 잘못 구현했을 경우 무한 재귀의 위험성

- 아래와 같이  ColorPoint , SmellPoint 에 대한 equals 구현시 myColorPoint.equals(mySmellPoint)를 호출할 경우 if (!(o instanceof ColorPoint)) return o.equals(this); 이부분과  if (!(o instanceof SmellPoint)) return o.equals(this); 이부분에서 서로를 계속 호출하게 되므로 무한 재귀에 빠지게 되어 StackOverFlowError가 발생한다.

```java
public class ColorPoint extends Point {
 private final Color color;

 public ColorPoint(int x, int y, Color color) {
     super(x, y);
     this.color = color;
 }

 @Override public boolean equals(Object o) {
     if (!(o instanceof Point))
         return false;
     if (!(o instanceof ColorPoint))
         return o.equals(this);
     return super.equals(o) && ((ColorPoint) o).color == color;
 }
}

public class SmellPoint extends Point {
 private final Smell smell;

 public SmellPoint (int x, int y, Smell smell) {
     super(x, y);
     this.smell = smell;
 }

 @Override public boolean equals(Object o) {
     if (!(o instanceof Point))
         return false;
     if (!(o instanceof SmellPoint))
         return o.equals(this);
     return super.equals(o) && ((SmellPoint) o).color == color;
 }
}
```

해결책

- 새로운 값을 추가하며 확장하는 구체 클래스가 equals 규약을 지킨 equals 메서드를 만드는 방법은 존재하지 않는다.

일관성

null 아님

### [용어 정리]

값 클래스

- 값을 표현하는 클래스 (예 : Integer, String)

동치관계

- 집합을 서로 같은 원소들로 이루어진 부분집합으로 나누는 연산

동치 클래스(quivalence class)

- 동치관계에 해당하는 부분집합

구체 클래스(concreate class)

- 추상 클래스가 아닌 모든 클래스. 구상 클래스, 구현 클래스로 부르기도 함.

Reference

[Concrete class == 구상클래스, 구현클래스, 구체클래스??]

[https://beomseok95.tistory.com/286](https://beomseok95.tistory.com/286)
