### [equals 메서드의 재정의]

재정의하지 않은 equals 메서드

- 자기 자신인 인스턴스만 같게 된다.

equals 메서드를 재정의하면 문제가 발생할 가능성이 높으므로 아래 경우에 해당한다면 재정의 하지 않는게 좋음.

equals를 재정의하지 않는 것이 좋은 경우

- 동작하는 개체를 표현하는 클래스의 인스턴스가 고유하다 (예 : Thread)
- 논리적 동치성을 검사할 필요가 없는 인스턴스 (예 : Pattern 인스턴스들의 정규식이 일치하는지 판단하는 로직을 만들 필요가 없다면 equals를 재정의할 필요가 없다.)
- 상위 클래스에 재정의한 equals가 하위 클래스에도 똑같이 적용이 될 경우
- 클래스가 private 또는 패키지가 private 이면서 equals를 사용할 일이 없는 경우

equals 메서드 호출 방지 방법

```java
@Override public boolean equals(Object o) {
	throw new AssertionError();
}
```

equals를 재정의하는 것이 좋을 경우

- 상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의하지 않았을 경우 (예 : 값 클래스의 비교) 즉 값이 같은걸 비교하고 싶은데 값 클래스의 equals가 두 객체가 물리적으로 같은가 (객체 식별성(object identity))를 판별할 경우

String과 같은 인스턴스 통재 클래스면 equals를 재정의안해도 논리적 동치성 판별이 가능해짐.

### [equals 메서드 일반 규약]

equals 메서드는 동치관계(equivalence relation)를 구현하고 아래를 성립해야 한다.

- 반사성(reflexivity)
    - null 아닌 참조값 x → x.equals(x) = true
- 대칭성(symmetry)
    - null 아닌 참조값 x,y → x.equals(y) = true 이면 y.equals(x) = true
- 추이성(transitivity)
    - null 아닌 참조값 x,y, z → x.equals(y) = true 이고 y.equals(z) = true 이면 x.quals(z) = true
- 일관성(consistency)
    - null 아닌 참조값 x,y → x.equals(y) loop 시 항상 true 또는 false를 반환
- null 아님
    - null 아닌 참조값 x → x.equals(null) = false

※ 수많은 클래스들이 equals 규악을 지키는 것을 가정하고 동작하므로 equals 재정의시 반드시 규약을 지켜야한다!!!

### [용어 정리]

값 클래스

- 값을 표현하는 클래스 (예 : Integer, String)
