### Comparable 인터페이스

정의

- compareTo 메서드를 가지고 있음
- 동치성 비교 + 순서 비교 + 제네릭
- Comparable 구현 객체는 자연스럽게 순서를 가지고 있다

compareTo 메서드 일반 규약

- 두 객체의 순서를 비교
    - x.compareTo(y) == -1 → x가 y보다 작다
    - x.compareTo(y) == 0  → x와 y가 같다
    - x.compareTo(y) == 1  → x가 y보다 크다
    - 서로 비교할 수 없는 타입일 경우 ClassCastException 던짐
- 모든 x,y
    - sgn(x.compareTo(y)) == - sgn(y.compareTo(x)) (sgn : 부호를 반별하는 함수)
- 추이성
    - ( x.compareTo(y) > 0 && y.compareTo(z) ) > 0 → x.compareTo(z) > 0
- 모든 z
    - x.compareTo(y) == 0 → sgn(x.compareTo(z)) == sgn(y.compareTo(z))
- 필수는 아니지만 지키면 좋은 것
    - (x.compareTo(y) == 0) == (x.eqauls(y))
    - 이 권고를 지키지 않을 경우 그 사실을 명시해야 함! (예 : 이 클래스의 순서는 equals 메서드와 일관되지 않는다.)
    - 정렬된 컬렉션은 동치성 비교시 equals 대신 compareTo를 사용한다. 이 규약을 지키지 않을 경우 이들이 구현한 인터페이스(Collection, Set, Map) 는 동치성 비교시 equals를 사용하므로 서로 다른 동작 결과를 가져오게 되므로 주의해야 한다.

    ```java
    BigDecimal num1 = new BigDecimal("1.0");
    BigDecimal num2 = new BigDecimal("1.00");

    Set<BigDecimal> hashSet = new HashSet<>();
    hashSet.add(num1);
    hashSet.add(num2);
    System.out.println(hashSet.size());//2출력 - num1, num2를 equals 비교로 다른 것으로 인식

    Set<BigDecimal> treeSet = new TreeSet<>();
    treeSet.add(num1);
    treeSet.add(num2);
    System.out.println(treeSet.size());//1출력 - num1, num2를 compareTo 비교로 같은 것으로 인식
    ```


특징 및 주의사항

- 타입이 다른 객체 비교할 경우대부분  ClassCastException 던짐
- 다른 타입 비교 허용할 경우 비교 객체들이 구현한 공통 인터페이스로 진행
- compareTo 규약을 어길시 비교 활용하는 클래스를 활용 불가능
    - (정렬된 컬렉션 : TreeSet, TreeMap, 검색, 정렬 알고리즘 활용 : Collections, Arrays)
