### Cloneable 인터페이스

Cloneable 인터페이스란?

- Object 안에 있는 protect 메서드인 clone 메서드의 동작 방식을 결정
- Cloneable 구현 클래스의 인스턴스에서 clone을 호출하면 객체의 필드들을 복사한 객체를 반환
- Cloneable을 구현하지 않은 클래스의 인스턴스에서 clone 호출 시 CloneNotSupportedException 발생

Cloneable의 위험성

- 사용자는 Cloneable을 구현한 클래스의 인스턴스에 있는 clone을 호출하면 복제가 제대로 이루어진다고 기대함.
- 허나 이는 허술한 Clone 일반 규약으로 인해 생성자를 호출하지 않고도 객체를 생성할 수 있으므로 위험하다.

clone 메서드 일반 규약

- 해당 객체의 복사본을 생성하여 반환
- ‘복사’ 라는 의미는 구현 클래스에 따라 다름
- 객체 x에 대한 다음 식은 참이다.
    - x.clone() != x
    - x.clone().getClass() == x.getClass()
- 객체 x에 대한 다음 식은 일반적으로 참이나 필수는 아니다.
    - x.clone().equals(x)
- 관례상 반환 객체는 super.clone() 을 호출해서 얻어야함. clone()으로 호출할 경우 자기 자신을 호출하여 재귀호출이 일어날 수 있으므로 주의 필요
- 관례상 반환 객체와 원본 객체는 독립적이어야 한다. 이를 위해선 super.clone으로 복사한 객체의 필드 하나 이상을 반환 전에 수정해야할 수도 있다.

super.clone을 호출하는 이유

- super.clone이 아닌 생성자를 호출한 인스턴스를 반환해도 컴파일러는 문제를 삼지 않는다. 그러나 다음과 같은 문제가 발생한다. B클래스가 A클래스를 상속할 때 A의 clone이 new A()와 같은 방식으로 생성자를 호출하여 인스턴스를 반환한다면 B의 clone도 A타입의 인스턴스를 반환할 수 밖에 없게 된다.

clone 재정의 모범 사례

```java
public final class PhoneNumber implements Cloneable {//Cloneable 구현
    private final short areaCode, prefix, lineNum;
    ...
    @Override public PhoneNumber clone() {
        try {
            return (PhoneNumber) super.clone();//super.clone 호출, 공변 반환 타이핑이 가능하므로 PhoneNumber로 형변환하여 반환
        } catch (CloneNotSupportedException e) {
            throw new AssertionError();
        }
    }
}
```

- try-catch 로 감싼 이유
    - Object clone 메서드가 검사 예외(checked exception)인 CloneNotSupportedException를 던지도록 설계되었기 때문에 강제해야 한다.

가변 객체를 참조하는 클래스를 clone할 때 생기는 문제

- 복제본이나 원본의 가변 객체가 수정되면 다른 하나도 수정이 되므로 문제가 생긴다.

예시 Stack 클래스

```java
public class Stack implements Cloneable {
    private Object[] elements;//가변 객체
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;

    public Stack() {
        this.elements = new Object[DEFAULT_INITIAL_CAPACITY];
    }

    public void push(Object e) {
        ensureCapacity();
        elements[size++] = e;
    }

    public Object pop() {
        if (size == 0)
            throw new EmptyStackException();
        Object result = elements[--size];
        elements[size] = null;
        return result;
    }

    public boolean isEmpty() {
        return size ==0;
    }

    private void ensureCapacity() {
        if (elements.length == size)
            elements = Arrays.copyOf(elements, 2 * size + 1);
    }
}
```

해결책

- 배열의 경우 clone을 호출하여 스택 내부 정보를 복사한다.

```java
@Override public Stack clone() {
        try {
            Stack result = (Stack) super.clone();
            result.elements = elements.clone();
            return result;
        } catch (CloneNotSupportedException e) {
            throw new AssertionError();
        }
    }
```

잘 이해가 안되는 말 정리

- p78 - 관례상 반환 객체와 원본 객체는 독립적이어야 한다. 이를 위해선 super.clone으로 복사한 객체의 필드 하나 이상을 반환 전에 수정해야할 수도 있다.

용어 정리

공변 반환 타이핑(covariant return typing)

- 재정의 메서드의 반환 타입은 상위 클래스의 메서드가 반환하는 타입의 하위 타입일 수 있다.

Reference

[자바, 객체 복사하는 clone() 메소드]

[https://blog.daum.net/sualchi/13720631](https://blog.daum.net/sualchi/13720631)
