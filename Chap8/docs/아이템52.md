### 다중정의의 위험성

아래와 같이 classify를 다중정의(overloading, 오버로딩)할 경우 예상과는 다르게 전부 “그 외”를 출력한다.

이유 : 재정의한 메서드는 동적으로 선택되고, 다중정의한 메서드는 정적으로 선택된다.

해석 : 다중정의할 경우 메서드 호출이 런타임이 아니라 컴파일타임에 결정되기 때문. for문 안에 Collection으로 타입을 지정했으므로 런타임에 타입이 달라저도 “그 외”가 3번 출력된다. 따라서 Collection타입 별로 분류해야 하는 프로그램 의도와 다르게 동작하게 된다.

```java
import java.util.*;
import java.math.*;

public class CollectionClassifier {
    public static String classify(Set<?> s) {
        return "집합";
    }

    public static String classify(List<?> lst) {
        return "리스트";
    }

    public static String classify(Collection<?> c) {
        return "그 외";
    }

    public static void main(String[] args) {
        Collection<?>[] collections = {
                new HashSet<String>(),
                new ArrayList<BigInteger>(),
                new HashMap<String, String>().values()
        };

        for (Collection<?> c : collections)
            System.out.println(classify(c));
    }
}
```

반면에 아래와 같이 재정의한 메서드는 가장 하위에서 재정의한 메서드가 실행됨. 따라서 “포도주”, “발포성 포도주”, “샴페인”이 출력됨.

```java
class Wine {
    String name() { return "포도주"; }
}

class SparklingWine extends Wine {
    @Override String name() { return "발포성 포도주"; }
}

class Champagne extends SparklingWine {
    @Override String name() { return "샴페인"; }
}

public class Overriding {
    public static void main(String[] args) {
        List<Wine> wineList = List.of(
                new Wine(), new SparklingWine(), new Champagne());

        for (Wine wine : wineList)
            System.out.println(wine.name());
    }
}
```

다중정의 문제 해결책

- 다중정의 메서드들을 하나로 합치고 instanceof로 명시적으로 검사

```java
public class FixedCollectionClassifier {
    public static String classify(Collection<?> c) {
        return c instanceof Set  ? "집합" :
                c instanceof List ? "리스트" : "그 외";
    }

    public static void main(String[] args) {
        Collection<?>[] collections = {
                new HashSet<String>(),
                new ArrayList<BigInteger>(),
                new HashMap<String, String>().values()
        };

        for (Collection<?> c : collections)
            System.out.println(classify(c));
    }
}
```

결론

- 안정적, 보수적으로 가려면 매개변수 수가 같은 다중정의는 만들지 않기
- 다중정의 대신 메서드 이름을 다르게 지어주는 방법 채택하기
